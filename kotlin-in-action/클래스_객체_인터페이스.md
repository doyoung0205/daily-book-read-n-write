### 클래스 객체 인터페이스

- [ ] 기능을 만들 때 프로퍼티와 메서드의 차이

## 목차

- 클래스와 인터페이스
- 뻔하지 않은 생성자와 프로퍼티
- 데이터 클래스
- 클래스 위임
- object 키워드 사용

---

- 코틀린에서 인터페이스는 프로퍼티가 선언이 들어갈 수 있다.
- 기본적으로 final 이며 public 이다.
- 중첩 클래스는 기본적으로는 내부 클래스가 아니다. 즉, 코틀린 중첩 클래스에는 외부 클래스에 대한 참조가 없다.
- 클래스를 data 로 선언하면 컴파일러가 일부 표준 메서드를 생성해준다.
- 코틀린 언어가 제공하는 위임을 사용하면 위임을 처리하기 위한 준비 메서드를 직접 작성할 필요가 없다.
- 싱글톤, 동반, 객체 식을 표현할 때 object 키워드를 쓴다.

## 클래스 계층 정의

클래스는 class, 인터페이스는 interface 로 정의

- 코틀린에서는 확장과 상속을 모두 `:` 를 사용한다. (java 에서는 extends 또는 implements)
- 자바의 @Override 애노테이션과 비슷하게 override 예약어를 사용한다. 자바와 달리 override 예약어를 사용하지 않으면 첨파일 오류가 발생하고
  이는 상위 클래스에 있는 메서드와 시그니처가 같은 메서드를 우연히 하위 클래스에서 선언하는 경우 컴파일이 안 되기 때문에 override 붙이거나 이름을 바꿔야만 한다.

### open, final, abstract 변경자: 기본적으로 final

자바에서는 final로 명시적으로 상속을 금지하지 않는 모든 클래스를 다른 클래스가 상속할 수 있다.
`취약한 기반 클래스` 라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨저벼린 경우가 있다.
어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메서드를 오버라이드할 위험이 있다.

모든 하위 클래스를 분석하는 것은 불가능하므로 기반 클래스를 변경하는 경우 하위 클래스의 동작이 예기치 않게 바뀔 수도 있다는 면에서 기반 클래스는 '취약'하다.

"상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 의도된 클래스와 메서드가 아니라면 모두 final로 만들어라"

어떤 클래스의 상속을 허용하려면 클래스 앞에 `open` 변경자를 붙여야 한다. 그와 더불어 오버라이드를 허용하고 싶은 메서드나 프로퍼티의 앞에도 open 변경자를 붙여야 한다.

![kotlin-modifier-table.png](kotlin-modifier-table.png)

```
열린 클래스와 스마트 캐스트

클래스의 기본적인 상속 가능 상태를 final로 함으로써 얻을 수 있는 큰 이익은 다양한 경우에 스마트 캐스트가 가능하다는 점이다.
스마트 캐스트는 타입 검사 뒤에 변경될 수 없는 변수에만 적용 가능하다. 
클래스 프로퍼티의 경우 이는 val 이면서 커스텀 접근자가 없는 경우에만 스마트 캐스트를 쓸 수 있다는 의미이다.
이 요구 사항은 또한 프로퍼티가 final 이어야만 한다는 뜻이기도 하다.


<<??>>
프로퍼티가 final 이 아니라면 그 프로퍼티를 다른 클래스가 상속하면서 커스텀 접근자를 정의함으로써 스마트 캐스트의 요구 사항을 깰 수 있다.
프로퍼티는 기본적으로 final 이기 때문에 따로 고민할 필요 없이 대부분의 프로퍼티를 스마트 캐스트에 활용할 수 있다.
이는 코드를 더 이해하기 쉽게 만든다.
```

### 가시성 변경자: 기본적으로 공개

| 변경자        | 클레스 맴버 | 최상위 선언          |
|------------|--------|-----------------|
| public(기본) | 모든 곳   | 모든 곳            |
| internal   | 같은 모듈  | 같은 모듈           |
| protected  | 하위 클래스 | (최상위 선언에 적용 불가) |
| private    | 같은 클래스 | 같은 파일           |

### 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스

코틀린은 중첩 클래스는 명시적으로 요청하지 않는 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다는 점이다.
코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같다.

(바깥쪽 클래스 에 대한 참조를 묵시적으로 포함하는 과정 때문에)


| 클래스 B 안에 정의된 클래스 A             | 자바             | 코틀린           |
|--------------------------------|----------------|---------------|
| 중첩 클래스(바깥쪽 클래스에 대한 참조를 저장하지 않음 | static class A | class A       |
| 내부 클래스(바깥쪽 클래스에 대한 참조를 저장함)    | class A        | inner class A |


### 봉인된 클래스


when 이 모든 경우를 처리하는지 제대로 검사할 수 없다. 혹 실수로 새로운 클래스 처리를 잊어벼렸더라도
디폴트 분기가 선택되기 때문에 심각한 버그가 발생할 수 있다.



`sealed` 변경자: 클래스 상속을 제한한다.
