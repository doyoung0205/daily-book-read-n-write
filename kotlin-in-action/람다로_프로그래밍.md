# 람다로 프로그래밍

람다 식 또는 람다는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.

## 공부하는 것

- 컬렉션을 처리하는 패턴을 표준 라이브러리 함수에 람다를 넘기는 방식으로 대치
- 자바 라이브러리와 람다를 함께 사용하는 방법
- **수신 객체 지정 람다**

## 람다 식 과 맴버 참조

### 람다 소개: 코드 블록을 함수 인자로 넘기기 

"이벤트가 발생하면 이 핸들러를 실행하자" 나 "데이터 구조의 모든 원소에 이 연산을 적용하자"

**이와 달리 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법을 택함으로써이 문제를 해결한다.**


```kotlin
button.setOnClickListener { /* 클릭 시 수행할 동작 */ }
```

### 람다와 컬렉션
```kotlin

fun main() {

    val people = listOf(Person3("Alice", 30), Person3("Bob", 31))
    println(people.maxBy { it.age }) // it이 그 인자를 가르킨다.
    println(findTheOldest(people))

}

data class Person3(val name: String, val age: Int)

fun findTheOldest(people: List<Person3>) {
    var maxAge = 0
    var theOldest: Person3? = null
    for (person in people) {
        if (person.age > maxAge) {
            maxAge = person.age
            theOldest = person
        }
    }
    println(theOldest)
}
```

코틀린 람다 식은 항상 중괄호로 싸여있다. 인자 목록 주변에 괄호가 없다는 사실을 꼭 기억하라.
화살표 (->) 가 인자 목록과 람다 본문을 구분해준다.

람다 식을 변수에 저장할 수 있다. 람다가 저장된 변수를 다른 일반 함수와 마찬가지로 다룰 수 있다.
(변수 이름 뒤에 괄호를 놓고 그 안에 필요한 인자를 넣어서 람다를 호출할 수 있다.)


실행 시점에 코틀린 호출에는 아무 부가 비용이 들지 않으며, 프로그램의 기본 구성 요소와 비슷한 성능을 낸다.
(8.2 절의 이유가 있다.)


---

코틀린에서는 자바와 달리 람다에서 람다 밖 함수에 있는 파이널이 아닌 변수에 접근할 수 있고 그 변수를 변경할 수 있다.

람다 안에서 사용하는 외부 변수를 '람다가 포획(capture) 한 변수' 라고 부른다.
기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝난다. 하지만 어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 
생명주기와 함수의 생명주기가 달라질 수 있다. 포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다.


### 변경 가능한 변수 포획하기: 자세한 구현 방법

자바에서는 파이널 변수만 포획할 수 있다. 하지만 교묘한 속임수를 통해 변경 가능한 변수를 포획할 수 있다.
그 속임수는 변경 가능한 변수를 저장하는 원소가 단 하나뿐인 배열을 선언하거나, 변경 가능한 변수를 필드로 하는 클래스를 선언하는 것이다.
(안에 들어있는 원소는 변경가능 할지라도 배열이나 클래스의 인스턴스에 대한 참조를 final로 만드면 포획이 가능하다)
이런 속임수를 코틀린으로 작성하면 다음과 같다.

class Ref<T>(var value: T)
>>> val counter = Ref(0) // 변경 가능한 변수를 포획하는 방법을 보여주기 위한 클래스
>>> val inc = {counter.value++} // 공식적으로는 변경 불가능한 변수를 포획했지만 그 변수가 가리키는 객체의 필드 값을 바꿀 수 있다.



실제 코드에서는 이런 래퍼를 만들지 않아도 된다. 대신, 변수를 직접 바꾼다.
val counter = 0
val inc = { counter++ }

이 코틀린 코드가 어떻게 작동할까? 첫 번째 예제는 두 번째 예제가 작동하는 내부 모습을 보여준다.

람다가 파이널 변수 (val) 를 포획하면 자바와 마찬가지로 그 변수의 값이 복사된다. 하지만 람다가 변경 가능한 변수 (var) 를 포획하면
변수를 Ref 클래스 인스턴스에 넣는다. 그 Ref 인스턴스에 대한 참조를 파이널로 만들면 쉽게 람다로 포획할 수 있고, 람다 안에서는 Ref 인스턴스의 필드를 변경할 수 있다.




### 함정

람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 가능 성이 있다.

```kotlin
fun tryToCountButtonClicks (button: Button): Int {
    var clicks = 0
    button.onClick { clicks ++ }
    return clicks
}
```



### all, any, count, find: 컬렉션에 술어 적용

