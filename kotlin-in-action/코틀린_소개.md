# 코틀린이란 무엇이며, 왜 필요한가?

자바에서 돌아가는 새로운 프로그램이 언어

코틀린은 간결하고 실용적이며, 자바 코드와의 상호운용성을 중요하게 생각한다.

기존 자바 프레임워크와 함께 잘 작동하며, 성능도 자바와 같은 수준이다.

## 코틀린 맛보기

```kotlin
data class Person(
    val name: String?,
    val age: Int? = null // 널이 될 수 잇는 타입과 파라미터 디폴트값
) // 데이터 클래스

fun main(args: Array<String>) { // 취상위 함수
    val persons = listOf(
        Person("영희"),
        Person("철수", age = 29) // 이름 붙인 파라미터
    )
    val oldest = persons.maxBy(it.age ?: 0) // 람다 식과 엘비스 연산자
    println("나이가 가장 많은 사람: $oledest") // 문자열 템플릿
}

// 결과: 나이가 가장 많은 사람: Person (name=철수, age=29) // toString 자동 생성

```

## 언어로서 코틀린이 갖는 특성

### 정적 타입지정 언어

컴파일 시점에 구성요소의 타입을 알 수 있다.

따라서 객체의 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증해준다.

동적언어는 타입과 관계없이 모든 값을 변수에 넣을 수 있고, 메서드나 필드 접근에 대한 검증이 실행 시점에 일어나며,
그에 따라 코드가 더 짧아지고 데이터 구조를 더 유연하게 생성할 수 있지만
반대로 이름을 잘못 입력하는 등의 실수도 컴파일 시 걸러내지 못하고 실행 시점에 오류가 발생한다.

코틀린에서는 타입추론을 지원하기 때문에
대부분의 경우 코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추할 수 있기 때문에 프로그래머는 타입 선언을 생략해도 된다.
```var x = 1```

정적 타입지정 언어의 장점

- 성능: 어떤 메서드를 호출할지 알아내는 과정이 없음으로 메서드 호출이 더 빠름
- 신뢰성: 컴파일러가 프로그램의 정확성을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 더 작아짐
- 유지 보수성: 다루는 객체가 어떤 타입에 속하는지 알 수 있기 때문에 처음 보는 코드를 다룰 때도 더 쉽다.
- 도구 지원: IDE 를 통해 안전하게 리팩토링 할 수 있다.

기존에 자바와 비슷하게 동작하는데 몇가지 새로운 점이 있다.

1. 널이 될 수 있는 타입 (nullable type)을 지원한다는 점 `NPE`가 발생할 수 있는지 여부를 검사할 수 있어서 좀 더 프로그램의 신뢰성을 높일 수 있다.
2. 함수 타입을 지원함에 따라 어떤 함수가 다른 함수를 파라미터로 받거나 함수가 새로운 함수를 반환할 수 있다.
3. 람다 식을 지원함으로 번거러운 준비 코드를 작성하지 않아도 코드 블록을 쉽게 정의하고 여기저기 전달할 수 있다.
4. 데이터 클래스는 불변적인 값 객체 (value object)를 간편하게 만들 수 있는 구문을 제공한다.

### 함수형 프로그래밍과 객체지향 프로그래밍을 함께

- 일급 시민인 함수: 함수를 일반 값처럼 다룰 수 있다. 함수를 인자로 전달할 수 있으며 함수를 반환할 수도 있다.
- 불변성: 내부 상태가 절대로 바뀌지 않는 불변 객체
- 부수효과 없음(side effect): 함수형 프로그래밍에서는 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호 작용하지 않는 순수 함수를 사용한다.

위의 장점으로 아래의 해텍을 누릴 수 있다.

- 간결성(함수를 타입으로 인식하기에 람다를 사용할 수 있다.)
- 다중 스레드를 사용해도 안전(불변과 순수 함수)
- 테스트하기 쉽다. (환경을 구성하는 준비 코드가 따로 필요하지마 순수 함수는 그런 준비 코드 없이 독릭접으로 테스트 할 수 있다.)

코틀린에서는 함수형 스타일을 지원하지만 강제하지 않고 명령형 방식이 더 적합한 경우라면 함수형 프로그래밍으로 작성하는 것을 추천한다.

## 코틀린의 철학

### 실용성

- 다년간 젯프레인이나 코틀린 커뮤니티 내부의 개발자들이 다년간 코틀린 초기 버전을 사용하면서 전달한 실용적인 피드백이 반영

- 코틀린은 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존한다.
  이로 인해 언어의 복잡도가 줄어들고 이미 알고 있는 기존 개념을 통해 코틀린을 더 쉽게 배울 수 있다.

- 도구의 의존
  코틀린의 경우 인텔리J IDEA 의 개발과 컴파일러의 개발이 맞물려 이뤄져 왔다. 코틀린 언어의 특성은 항상 도구의 활용을 염두에 두고 개발돼 왔다.
  더 간결한 구조로 바꿀 수 있는 대부분의 코드 패턴을 도구가 자동으로 감지해서 수정하라고 제안한다.

### 간결성

개발자는 코드를 작성하는 시간보다 읽는 시간이 더 오래 걸린다.
코드가 간결하면 작성하는 시간이 줄어지지만 더 중요한 것은 읽는 시간이 더 적게 걸린다는 것이다.

```
따라서 언어를 간결하게 만들려고 노력하고 있다.
언어가 간결하다는 말은 그 언로 작성된 코드를 읽을 때 의도를 쉽게 파악할 수 있는 구문 구조를 제공하고, 그 의도를 달성하는 방법을 이해할 때
방해가 될 수 있는 부가적인 준비 코드가 적다는 뜻이다.
```

- getter, setter, 생성자 파라미터 번거로운 코드를 코틀린에서 묵시적으로 제공한다.
- 람다 사용 가능
- 연산자 오버로딩을 지원하지만, 언어가 제공하지 않는 연산자를 프로그래머가 정의할 수 있도록 허용하지 않는다.
  ```연산자 오버로딩 **과 같은 새로운 연산자를 정의하는 것```

### 안정성

자바와 같이 타입 안정성을 제공한다. 하지만 자바보다 더 적은 비용으로 타입 안정성을 사용할 수 있다.

- 타입추론을 자동으로 해주기 때문에 직접 타입 정보를 지정할 필요가 없다.
  **NPE를 없애기 위해 Null 이 가능하지 않은 타입을 제공한다.**
- ClassCastException 어떤 객체를 다른 타입으로 캐스트하기 전에 타입을 미리 검사하지 않으면 ClassCastException 발생할 수있는데
  **코틀린에서는 타입 검사와 캐스트가 한 연산자에 의해 이뤄진다.**

### 상호운용성

기존 라이브러리를 그대로 사용할 수 있다.

이에 따라 자바와 코틀린 코드를 프로젝트에서 원하는 대로 섞어 쓸 수 있어 궁극적인 유연성을 발휘할 수 있다.
이유는 코틀린은 자바 표준 라이브러리에 의존하기 때문이다. 다만 코틀린에서 컬렉션을 더 쉽게 활용할 수 있게 몇 가지 기능을 더할 뿐이다.
